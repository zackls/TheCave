#include "mylib.h"

#define DMA_DST_INC (0 << 21)
#define DMA_DST_DEC (1 << 21)
#define DMA_DST_FIXED (2 << 21)
#define DMA_DST_RESET (3 << 21)

#define DMA_SRC_INC (0 << 23)
#define DMA_SRC_DEC (1 << 23)
#define DMA_SRC_FIXED (2 << 23)

#define DMA_REPEAT (1 << 25)

#define DMA_16 (0 << 26)
#define DMA_32 (1 << 26)

#define DMA_NOW (0 << 28)
#define DMA_AT_VBLANK (1 << 28)
#define DMA_AT_HBLANK (2 << 28)
#define DMA_AT_REFRESH (3 << 28)

#define DMA_IRQ (1 << 30)

#define DMA_ENABLE (1 << 31)

typedef struct
{
	const void *src;
	void *dst;
	unsigned int cnt;
} DMAREC;

#define dma_mem ((volatile DMAREC*)0x040000B0)

volatile unsigned short *REG_VCOUNT = (volatile unsigned short*) 0x04000006;
unsigned short *videoBuffer = (unsigned short*) 0x6000000;

//alphabet is from TONC: "http://www.coranac.com/tonc/text/text.htm"
const unsigned int alphabet[190] =
{
	0x00000000, 0x00000000, 0x18181818, 0x00180018, 0x00003636, 0x00000000, 0x367F3636, 0x0036367F, 
	0x3C067C18, 0x00183E60, 0x1B356600, 0x0033566C, 0x6E16361C, 0x00DE733B, 0x000C1818, 0x00000000, 
	0x0C0C1830, 0x0030180C, 0x3030180C, 0x000C1830, 0xFF3C6600, 0x0000663C, 0x7E181800, 0x00001818, 
	0x00000000, 0x0C181800, 0x7E000000, 0x00000000, 0x00000000, 0x00181800, 0x183060C0, 0x0003060C, 
	0x7E76663C, 0x003C666E, 0x181E1C18, 0x00181818, 0x3060663C, 0x007E0C18, 0x3860663C, 0x003C6660, 
	0x33363C38, 0x0030307F, 0x603E067E, 0x003C6660, 0x3E060C38, 0x003C6666, 0x3060607E, 0x00181818,
	0x3C66663C, 0x003C6666, 0x7C66663C, 0x001C3060, 0x00181800, 0x00181800, 0x00181800, 0x0C181800, 
	0x06186000, 0x00006018, 0x007E0000, 0x0000007E, 0x60180600, 0x00000618, 0x3060663C, 0x00180018, 
	0x5A5A663C, 0x003C067A, 0x7E66663C, 0x00666666, 0x3E66663E, 0x003E6666, 0x06060C78, 0x00780C06, 
	0x6666361E, 0x001E3666, 0x1E06067E, 0x007E0606, 0x1E06067E, 0x00060606, 0x7606663C, 0x007C6666, 
	0x7E666666, 0x00666666, 0x1818183C, 0x003C1818, 0x60606060, 0x003C6660, 0x0F1B3363, 0x0063331B, 
	0x06060606, 0x007E0606, 0x6B7F7763, 0x00636363, 0x7B6F6763, 0x00636373, 0x6666663C, 0x003C6666, 
	0x3E66663E, 0x00060606, 0x3333331E, 0x007E3B33, 0x3E66663E, 0x00666636, 0x3C0E663C, 0x003C6670, 
	0x1818187E, 0x00181818, 0x66666666, 0x003C6666, 0x66666666, 0x00183C3C, 0x6B636363, 0x0063777F, 
	0x183C66C3, 0x00C3663C, 0x183C66C3, 0x00181818, 0x0C18307F, 0x007F0306, 0x0C0C0C3C, 0x003C0C0C, 
	0x180C0603, 0x00C06030, 0x3030303C, 0x003C3030, 0x00663C18, 0x00000000, 0x00000000, 0x003F0000, 
	0x00301818, 0x00000000, 0x603C0000, 0x007C667C, 0x663E0606, 0x003E6666, 0x063C0000, 0x003C0606, 
	0x667C6060, 0x007C6666, 0x663C0000, 0x003C067E, 0x0C3E0C38, 0x000C0C0C, 0x667C0000, 0x3C607C66, 
	0x663E0606, 0x00666666, 0x18180018, 0x00301818, 0x30300030, 0x1E303030, 0x36660606, 0x0066361E,
	0x18181818, 0x00301818, 0x7F370000, 0x0063636B, 0x663E0000, 0x00666666, 0x663C0000, 0x003C6666, 
	0x663E0000, 0x06063E66, 0x667C0000, 0x60607C66, 0x663E0000, 0x00060606, 0x063C0000, 0x003E603C, 
	0x0C3E0C0C, 0x00380C0C, 0x66660000, 0x007C6666, 0x66660000, 0x00183C66, 0x63630000, 0x00367F6B, 
	0x36630000, 0x0063361C, 0x66660000, 0x0C183C66, 0x307E0000, 0x007E0C18, 0x0C181830, 0x00301818, 
	0x18181818, 0x00181818, 0x3018180C, 0x000C1818, 0x003B6E00, 0x00000000
};

//0xFFFF used to denote transparency
//width = height = 16
const unsigned short goldNugget[256] =
{
	0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088,
	0x0088, 0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088, 0x0088,
	0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088,
	0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088,
	0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088,
	0x0088, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x7FFF, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x0088,
	0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x7FFF, 0x7FFF, 0x7FFF, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9,
	0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x7FFF, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9,
	0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9,
	0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9,
	0x0088, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x0088,
	0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088,
	0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x035F, 0x035F, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088,
	0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088,
	0x0088, 0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088, 0x0088,
	0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x02B9, 0x02B9, 0x02B9, 0x02B9, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088, 0x0088
};

const unsigned short playerWidth = 4;
const unsigned short playerHeight = 6;
//8 different 4x6 images for different rotations
const unsigned short player[192] =
{
	//vertical
	0xFFFF, 0xFFFF, 0xFFFF, 0x3DEF,
	0xFFFF, 0xFFFF, 0xFFFF, 0x3DEF,
	0xFFFF, 0x1194, 0x1194, 0x3DEF,
	0x12CA, 0x1194, 0x1194, 0x12CA,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//1/8 turn
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x12CA, 0xFFFF, 0xFFFF, 0xFFFF,
	0x1194, 0x1194, 0xFFFF, 0x3DEF,
	0x1194, 0x1194, 0x3DEF, 0xFFFF,
	0xFFFF, 0x12CA, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//right
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x12CA, 0xFFFF, 0xFFFF, 0xFFFF,
	0x1194, 0x1194, 0xFFFF, 0xFFFF,
	0x1194, 0x1194, 0xFFFF, 0xFFFF,
	0x12CA, 0x3DEF, 0x3DEF, 0x3DEF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//3/8 turn
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0x12CA, 0xFFFF, 0xFFFF,
	0x1194, 0x1194, 0x3DEF, 0xFFFF,
	0x1194, 0x1194, 0xFFFF, 0x3DEF,
	0x12CA, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//down
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x12CA, 0x1194, 0x1194, 0x12CA,
	0x3DEF, 0x1194, 0x1194, 0xFFFF,
	0x3DEF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x3DEF, 0xFFFF, 0xFFFF, 0xFFFF,
	//5/8 turn
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x12CA, 0x1194, 0x1194, 0xFFFF,
	0xFFFF, 0x1194, 0x1194, 0x12CA,
	0xFFFF, 0xFFFF, 0x3DEF, 0xFFFF,
	0xFFFF, 0x3DEF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//left
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0x3DEF, 0x3DEF, 0x3DEF, 0x12CA,
	0xFFFF, 0xFFFF, 0x1194, 0x1194,
	0xFFFF, 0xFFFF, 0x1194, 0x1194,
	0xFFFF, 0xFFFF, 0xFFFF, 0x12CA,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	//7/8 turn
	0xFFFF, 0x3DEF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0x3DEF, 0xFFFF,
	0xFFFF, 0x1194, 0x1194, 0x12CA,
	0x12CA, 0x1194, 0x1194, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
	0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF
};

//initializes some variables in the bullet struct so they don't need to be at runtime
const bullet basicBullet =
{
	0, 0, 0, 0, 3, 3, 1
};

//images for different structs of enemies
const unsigned short basicEnemyImage[16] = 
{
	0x3DEF, 0x3DEF, 0x3DEF, 0x3DEF,
	0x3DEF, 0x001F, 0x001F, 0x3DEF,
	0x3DEF, 0x001F, 0x001F, 0x3DEF,
	0x3DEF, 0x3DEF, 0x3DEF, 0x3DEF
};
const unsigned short largeEnemyImage[25] = 
{
	0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
	0x7C00, 0x7C00, 0x001F, 0x7C00, 0x7C00,
	0x7C00, 0x001F, 0x001F, 0x001F, 0x7C00,
	0x7C00, 0x7C00, 0x001F, 0x7C00, 0x7C00,
	0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00
};
const unsigned short fastEnemyImage[16] = 
{
	0x03D0, 0x03D0, 0x03D0, 0x03D0,
	0x03D0, 0x001F, 0x001F, 0x03D0,
	0x03D0, 0x001F, 0x001F, 0x03D0,
	0x03D0, 0x03D0, 0x03D0, 0x03D0
};
const unsigned short superEnemyImage[25] = 
{
	0x03FF, 0x03FF, 0x03FF, 0x03FF, 0x03FF,
	0x03FF, 0x001F, 0x001F, 0x001F, 0x03FF,
	0x03FF, 0x001F, 0x001F, 0x001F, 0x03FF,
	0x03FF, 0x001F, 0x001F, 0x001F, 0x03FF,
	0x03FF, 0x03FF, 0x03FF, 0x03FF, 0x03FF
};
const unsigned short giantEnemyImage[36] = 
{
	0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,
	0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,
	0x7C1F, 0x7C1F, 0x001F, 0x001F, 0x7C1F, 0x7C1F,
	0x7C1F, 0x7C1F, 0x001F, 0x001F, 0x7C1F, 0x7C1F,
	0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,
	0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F, 0x7C1F,
};
const unsigned short insaneEnemyImage[25] = 
{
	0x7FE0, 0x7FE0, 0x7FE0, 0x7FE0, 0x7FE0,
	0x7FE0, 0x001F, 0x001F, 0x001F, 0x7FE0,
	0x7FE0, 0x001F, 0x7FE0, 0x001F, 0x7FE0,
	0x7FE0, 0x001F, 0x001F, 0x001F, 0x7FE0,
	0x7FE0, 0x7FE0, 0x7FE0, 0x7FE0, 0x7FE0
};
const unsigned short sprintEnemyImage[9] = 
{
	0x7FFF, 0x7FFF, 0x7FFF,
	0x7FFF, 0x001F, 0x7FFF,
	0x7FFF, 0x7FFF, 0x7FFF
};
//initializes variables for different enemy structs
const enemy basicEnemy =
{
	0, 0, 8, 0, 0, 4, 4, 8, 2, 1, basicEnemyImage
};
const enemy largeEnemy =
{
	0, 0, 20, 0, 0, 5, 5, 24, 5, 1, largeEnemyImage
};
const enemy fastEnemy =
{
	0, 0, 5, 0, 0, 4, 4, 10, 8, 1, fastEnemyImage
};
const enemy superEnemy =
{
	0, 0, 7, 0, 0, 5, 5, 20, 10, 1, superEnemyImage
};
const enemy giantEnemy =
{
	0, 0, 15, 0, 0, 6, 6, 70, 15, 1, giantEnemyImage
};
const enemy insaneEnemy =
{
	0, 0, 6, 0, 0, 5, 5, 75, 20, 1, insaneEnemyImage
};
const enemy sprintEnemy =
{
	0, 0, 2, 0, 0, 3, 3, 12, 15, 1, sprintEnemyImage
};

void dma_copy(void *dst, const void *src, unsigned int count)
{
	dma_mem[3].cnt = 0;
	dma_mem[3].dst = dst;
	dma_mem[3].src = src;
	dma_mem[3].cnt = count | DMA_NOW | DMA_ENABLE;
}

void dma_fill(void *dst, volatile unsigned short src, unsigned int count)
{
    dma_mem[3].cnt = 0;
    dma_mem[3].src = (const void*)&src;
    dma_mem[3].dst = dst;
    dma_mem[3].cnt = count | DMA_SRC_FIXED | DMA_NOW | DMA_ENABLE;
}

void fillRect(int x, int y, int width, int height, unsigned short color)
{
	if (x < 0) 
	{
		width = width + x;
		x = 0;
	}
	if (y < 0) 
	{
		height = height + y;
		y = 0;
	}
	if (x + width >= 240)
	{
		width = 240 - x;
	}
	if (y + height >= 160)
	{
		height = 160 - y;
	}
	if (width > 0 && height > 0)
	{
		for (int i = 0; i < height; i++)
		{
			dma_fill(&videoBuffer[x + (y + i) * 240], color, width);
		}
	}
}

void fillDiamond(int x, int y, int size, unsigned short color)
{
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (i + j >= size / 2
				&& i + j <= 3 * (size - 1) / 2
				&& i - j > -(size + 1) / 2
				&& j - i > -(size + 1) / 2)
			{
				fillPixel(x + i, y + j, color);
			}
		}
	}
}

void fillPixel(int x, int y, unsigned short color)
{
	videoBuffer[x + y * 240] = color;
}

void clearScreen()
{
	dma_fill(videoBuffer, 0, 240 * 160);
}

void erase(int x, int y, int width, int height)
{
	fillRect(x, y, width, height, 0);
}

void drawImage3(int x, int y, int width, int height, const unsigned short *image)
{
	if (x < 0) 
	{
		width = width + x;
		x = 0;
	}
	if (y < 0) 
	{
		height = height + y;
		y = 0;
	}
	if (x + width >= 240)
	{
		width = 240 - x;
	}
	if (y + height >= 160)
	{
		height = 160 - y;
	}
	if (width > 0 && height > 0)
	{
		for (int i = 0; i < height; i++)
		{
			dma_copy(&videoBuffer[x + (y + i) * 240], &image[i * width], width | DMA_DST_INC | DMA_SRC_INC);
		}
	}
}
//identical to drawImage3 but allows for transparent pixels, denoted by 0xFFFF, and doesn't use DMA optimization
void drawImage(int x, int y, int width, int height, const unsigned short *image)
{
	if (x < 0) 
	{
		width = width + x;
		x = 0;
	}
	if (y < 0) 
	{
		height = height + y;
		y = 0;
	}
	if (x + width >= 240)
	{
		width = 240 - x;
	}
	if (y + height >= 160)
	{
		height = 160 - y;
	}
	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			//0xFFFF denotes transparency, so we skip those values
			if (image[j + i * width] != 0xFFFF)
			{
				videoBuffer[(y + i) * 240 + x + j] = image[j + i * width];
			}
		}
	}
}

//turnAmount = 0 for vertical, 1 for 1/8 turn, 2 for right, etc
void drawPlayer(int x, int y, unsigned short turnAmount)
{
	drawImage(x, y, playerWidth, playerHeight, (unsigned short*)((unsigned short*)&player + (turnAmount % 8) * 24));
}

//draws the text passed in
void drawText(int x, int y, char *str, unsigned short color)
{
	int c = 0;
	short int shiftY = 0;
	short int xOffset = 0;
	while (str[c] != '\0')
	{
		char charCode = str[c];
		if (charCode == 10)
		{
			shiftY += 10;
			xOffset += c - xOffset + 1;
		}
		else
		{
			unsigned int topValue = alphabet[2 * (charCode - 32)];
			unsigned int bottomValue = alphabet[2 * (charCode - 32) + 1];
			for (int i = 0; i < 64; i++)
			{
				if (i < 32)
				{
					if ((topValue >> i) & 1)
					{
						fillPixel(x + (i % 8) + (c - xOffset) * 8, y + (i / 8) + shiftY, color);
					}
				}
				else
				{
					if ((bottomValue >> (i - 32)) & 1)
					{
						fillPixel(x + (i % 8) + (c - xOffset) * 8, y + (i / 8) + shiftY, color);
					}
				}
			}
		}
		c++;
	}
}

//indicates whether or not the object is within valid bounds (inside the screen and outside the center gold piece)
int inBounds(int x, int y, int width, int height)
{
	//check edges of the screen
	if (x + width > 240 || x < 0 || y + height > 160 || y < 10 ||
		//check center gold piece
		(x + width > 112 && x < 128 && y + height > 82 && y < 98))
	{
		return 0;
	}
	return 1;
}

void waitForVBlank()
{
    while(*REG_VCOUNT >= 160);   // wait till VDraw
    while(*REG_VCOUNT < 160);    // wait till VBlank
}